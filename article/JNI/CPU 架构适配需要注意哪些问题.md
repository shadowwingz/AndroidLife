- Native 开发才会关注 CPU 架构
- 不同 CPU 架构之间的兼容性如何
- so 库太多如何优化 Apk 体积
- SDK 开发者应当提供哪些 so 库

## CPU 架构种类

在 Android 开发中，CPU 架构主要有以下几种：

> mips64、x86_64、arm64-v8a、armeabi-v7a、armeabi、mips、x86。

它们支持的设备类型如下：

|  设备类型   | 支持so库  |说明  |
|  ----  | ----  |----  |
| ARMv5 设备  | 只支持armeabi |早期 |
| ARMv7 设备  | 支持 armeabi 和 armeabi-v7a |从2010年起 |
| ARMv8 设备  | 支持 armeabi-v7a、armeabi 和 arm64-v8a |2014年起 |
| X86 设备  | 支持 armeabi(性能有所损耗) 和 x86 |主要是运用在平板上 |
| x86_64 设备  | 支持 x86 和 x86_64、armeabi |主要是运用在平板上 |
| mips 设备  | 支持 mips |较少 |
| mips_64 设备  | 支持 mips 和 mips_64 |较少 |

从表中可以看出，armeabi 支持的设备最多，因此兼容性最好。

## Android 加载 so 库策略

1. 手机加载 so 库时会先找自己 CPU 架构对应的目录，然后从目录下寻找需要的 so 库。如果可以找到 so 库就正常加载。
2. 如果没有找到对应架构的 so 库目录中，就会去 armeabi 目录下去找。如果在 armeabi 目录下找到了 so 库，就正常加载。
3. 如果在 armeabi 目录下没有找到 so 库，就抛异常。

> 比如我们在 armeabi-v7a 设备上加载 so 库，首先会去寻找 libs 目录下的 armeabi-v7a 文件夹，如果 armeabi-v7a 文件夹中没有 so 库，会直接报错。如果没有找到 armeabi-v7a 文件夹，会继续往下找，不会报错。接着找 armeabi 文件夹，如果 armeabi 文件夹中有 so 库，就正常加载，如果没有 so 库，会直接报错。

从这个流程中可以看出，加载 so 库，如果找不到目标目录还可以找别的目录，如果找到了目标目录，却找不到 so 库，就会直接崩掉...

但是有一点需要注意：如果在非 armeabi 的机型上运行 armeabi 架构的 so 库，so 库会以兼容模式来运行。

以兼容模式来运行的话，就会有一些问题：

- 兼容运行运行的 so 库无法获得最优性能
- 兼容模式容易出现一些难以排查的内存问题

## 提供哪几种架构的 so 库比较好

最理想的情况是每种架构都提供 so 库，这样 App 肯定能正常加载 so 库，而且没有性能问题。但是这样会造成 App 体积大小激增，所以我们得换个方案。

那就只提供 armeabi 架构的 so 库，这种 so 库的兼容性最好，常见架构的设备都能正常加载 so 库，只是在非 armeabi 架构的设备上，性能会稍打折扣。不过如果对性能不敏感的话，也还好啦。

那么有没有一种方案，既可以保证 so 库的正常加载，又能兼顾性能呢？

有的，动态下发 so 库。

我们可以先把 so 库放在我们自己的服务器上。然后先获取设备的架构类型，然后从服务器下载对应架构的 so 库，这样就可以保证 so 库的架构是刚好对应的。

## SDK 开发者需要注意的事项

如果我们 SDK 开发者，那我们要注意哪些呢？

首先，在实现功能时，能用 Java 写就用 Java 写，除非功能对性能十分敏感，才得用 C++ 来写，这样可以降低问题跟踪维护成本。

同时，要尽量优化 so 库的体积，因为我们写的 so 库是需要别人来集成的，如果别人集成了我们的 so 库，Apk 体积增加了几十 M，那就不好了。用户下载 Apk 会多花费不少流量。

最后，必须提供完整的 CPU 架构依赖，不能只提供 `armeabi-v7a` 或者 `arm64-v8a`，要所有的 CPU 架构全部提供，然后让开发者自己选择集成哪些架构的 so 库。如果只提供一种架构，极有可能导致开发者的 Apk 启动时 Crash。