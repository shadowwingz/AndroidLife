在日常的开发中，我们好像并不会直接用到动态代理这东西，不过 Retrofit 想必大家都用过，而 Retrofit 就用到了动态代理。

在前面讲静态代理的时候，我们说了，静态代理需要我们自己去写代理类。如果接口少还好说，接口多了那简直就是灾难。而动态代理就能很好的解决这个问题，为什么呢？因为它可以动态的根据我们的接口去生成代理，从此告别手写代理。

比较常见的动态代理是 JDK 动态代理。JDK 动态代理主要涉及两个类：`java.lang.reflect.Proxy` 和 `java.lang.reflect.InvocationHandler`。

`java.lang.reflect.Proxy` 的作用是帮助我们创建动态代理的对象，这样我们就不用去为每一个接口对象都创建一个 XXXProxy 对象了。直接一个动态代理对象就能搞定了。

`java.lang.reflect.InvocationHandler` 是调用请求处理器，当我们调用动态代理的方法时，调用请求会被转发到 InvocationHandler 的 invoke 方法中，最终由 InvocationHandler 完成调用请求。

我们用动态代理再来实现一下统计方法耗时的功能。首先，我们要新建一个类实现 InvocationHandler 接口，整个类会持有一个 Object 对象，这个 Object 对象是被代理的对象，在本例中是 UserServiceImpl。另外，我们还需要在 InvocationHandler 的 invoke 方法中实现逻辑处理。

```java
public class LogHandler implements InvocationHandler {

    // 被代理的对象，这里是 UserServiceImpl
    Object target;

    public LogHandler(Object target) {
        this.target = target;
    }

    // 当调用 UserService 的 select/update 方法时，会触发 invoke 方法被调用
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("方法名： " + method.getName());
        before();
        Object result = method.invoke(target, args);
        after();
        return result;
    }

    private void before() {
        System.out.printf("log start time [%s]%n", System.currentTimeMillis());
    }

    private void after() {
        System.out.printf("log end time [%s]%n", System.currentTimeMillis());
    }
}
```

接着，我们需要创建一个动态代理对象。

```java
public class Client2 {
    public static void main(String[] args) {
        // UserService 接口的实现类
        UserServiceImpl userServiceImpl = new UserServiceImpl();
        // 获取 ClassLoader
        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();
        // 获取类实现的接口，UserServiceImpl 实现了 UserService 接口，因此这里会获取到 UserService 接口
        Class[] interfaces = userServiceImpl.getClass().getInterfaces();
        // 调用请求处理器，当我们调用 proxy 的 select/update 方法时，实际会触发 logHandler 的 invoke 方法被调用，
        // 相当于我们的调用请求被转发给了 LogHandler 来处理。
        InvocationHandler logHandler = new LogHandler(userServiceImpl);
        // 创建动态代理对象 proxy，这里的 proxy 相当于静态代理中的 UserServiceProxy
        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);
        // 当调用 proxy 的 select/update 方法时，会触发 logHandler 的 invoke 方法被调用
        proxy.select();
        proxy.update();
    }
}
```

运行结果：

```
方法名： select
log start time [1634562133851]
查询
log end time [1634562133868]
方法名： update
log start time [1634562133869]
更新
log end time [1634562133869]
```

可以看到，有了 LogHandler，UserServiceProxy 就不再需要了，无论 UserServiceImpl 再怎么新增或者修改接口，我们都不用再操心代理类，因为 `Proxy.newProxyInstance` 会帮助我们生成一个类似 UserServiceProxy 的代理类。

生成的代理类是什么样子呢？