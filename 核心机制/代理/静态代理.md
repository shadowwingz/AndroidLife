
## 先实现一个小功能

在讲静态代理，我们先实现一个小功能。

假如我们要实现一个用户系统，这个用户系统为简单起见，只有查询和更新两个功能。我们可以用 UserService 来表示：

```java
public interface UserService {
    void select();

    void update();
}
```

这里只定义了接口，很显然，我们还需要定义它的实现类。

```java
public class UserServiceImpl implements UserService {
    @Override
    public void select() {
        System.out.println("查询");
    }

    @Override
    public void update() {
        System.out.println("更新");
    }
}
```

到这里，就基本完成了这个用户系统。我们写个类简单测试一下：

```java
public class Client1 {

    public static void main(String[] args) {
        UserService userServiceImpl = new UserServiceImpl();

        userServiceImpl.select();
        userServiceImpl.update();
    }
}
```

打印：

```
查询
更新
```

## 增加功能：统计方法耗时

上面的功能实在是太简单了，因此我们考虑增加点功能，统计方法耗时。我们可以在方法执行的前后打印当前时间戳，这样我们就能知道方法执行大致花了多长时间。

不过，我们要在哪里打印时间戳呢？第一反应是 UserServiceImpl 中，大概是这个样子：

```java
public class UserServiceImpl implements UserService {
    @Override
    public void select() {
        before();
        System.out.println("查询");
        after();
    }

    @Override
    public void update() {
        before();
        System.out.println("更新");
        after();
    }

    private void before() {
        System.out.printf("log start time [%s]%n", System.currentTimeMillis());
    }

    private void after() {
        System.out.printf("log end time [%s]%n", System.currentTimeMillis());
    }
}
```

但是我们再思考一下，UserServiceImpl 这个类的职责是什么？实现用户系统的功能，也就是查询和更新。而打印时间戳这个功能并不属于用户系统的功能，因此不大适合写在 UserServiceImpl 中。我们可以单独用一个类来实现打印时间戳功能。这个类大概是这个样子：

```java
public class UserServiceProxy implements UserService {

    // 被代理的对象，也就是 UserServiceImpl
    private UserService target;

    public UserServiceProxy(UserService target) {
        this.target = target;
    }

    @Override
    public void select() {
        before();
        // 实际调用 UserServiceImpl 的 select 方法
        target.select();
        after();
    }

    @Override
    public void update() {
        before();
        // 实际调用 UserServiceImpl 的 update 方法
        target.update();
        after();
    }

    private void before() {
        System.out.printf("log start time [%s]%n", System.currentTimeMillis());
    }

    private void after() {
        System.out.printf("log end time [%s]%n", System.currentTimeMillis());
    }
}
```

测试类：

```java
public class Client1 {

    public static void main(String[] args) {
        UserService userServiceImpl = new UserServiceImpl();

        // userServiceImpl.select();
        // userServiceImpl.update();
        UserService proxy = new UserServiceProxy(userServiceImpl);
        proxy.select();
        proxy.update();
    }
}



但是这样也有缺点，目前接口中只有一个 get 方法，如果后续方法数量增加，增加到 50 个，那 Proxy 也得同步增加 50 个方法，这样维护成本会比较高。另外，我们也可以看出，这里一个代理对象 Proxy 对应了一个 HttpApi 接口。如果我们有很多接口，那我们也得有很多代理类对象。