功能接口：

```java
public interface HttpApi {
    String get();
}
```

实现类：

```java
public class RealModule implements HttpApi {
    @Override
    public String get() {
        return "www.baidu.com";
    }
}
```

代理类：

```java
public class Proxy implements HttpApi {

    private HttpApi target;

    public Proxy(HttpApi target) {
        this.target = target;
    }

    @Override
    public String get() {
        String url = target.get();
        System.out.println("proxy " + url);
        return url;
    }
}
```

测试类：

```java
public class Test {
    public static void main(String[] args) {
        // 静态代理
        HttpApi httpApi = new Proxy(new RealModule());
        String url = httpApi.get();
        System.out.println(url);
    }
}
```

分别介绍一下各个类：

- 功能接口 HttpApi

它的作用是返回一个 url。

- 实现类 RealModule

它实现了 `HttpApi` 接口，并返回 `www.baidu.com` url。

- 代理类 Proxy

实现了 `HttpApi` 接口并持有一个 HttpApi 对象，在 get 方法中会调用 HttpApi 的 get 的方法，并打印一行 log。

- 测试类 Test

测试代理类


可以看到，在测试类 Test 中，我们调用 httpApi.get() 是想返回一个 url。如果我们不仅想要返回一个 url，还想打印一下 log 呢。

那我们可以把打印 log 的代码加在 RealModule 中，但是 RealModule 的职责并不是打印 log，它的职责只是返回 url。

所以我们可以把打印 log 的任务交给 Proxy 代理类。这样可以在不修改 RealModule 代码的前提下扩展 RealModule 的功能。具体做法是让 Proxy 也实现 HttpApi 接口，并持有一个 HttpApi 对象。当调用接口方法的时候，会先执行 Proxy 中特有的逻辑，比如打印 log，然后再调用持有 HttpApi 对象的方法。

```java
@Override
public String get() {
    // 调用 HttpApi 的 get 方法
    String url = target.get();
    // 打印 log
    System.out.println("proxy " + url);
    return url;
}
```

但是这样也有缺点，目前接口中只有一个 get 方法，如果后续方法数量增加，增加到 50 个，那 Proxy 也得同步增加 50 个方法，这样维护成本会比较高。另外，我们也可以看出，这里一个代理对象 Proxy 对应了一个 HttpApi 接口。如果我们有很多接口，那我们也得有很多代理类对象。